{"name":"Intravenous","body":"# Intravenous\r\n***\r\nA lightweight zero-dependency [inversion of control container](http://martinfowler.com/articles/injection.html) for Javascript.\r\n\r\n### What? Why?\r\nIf you are building complex applications it can become very difficult to manage object lifetimes and dependencies. For instance, if you're building a UI you may want to create a dialog. The dialog's model may have dependencies on a logger, Growlesque notification thing, etc. It'll probably also contain some sub-models to display inside the dialog. You need to track all these dependencies and when the dialog closes you want to dispose some of the models (but not all, since the logger is probably a singleton) and so on... Complex! Unless you use an IoC container like this one.\r\n\r\nWith *Intravenous* you create a _container_ and tell this container which services are available in your system. Then, when you have class that wants to use these services you simply list them as dependencies. You tell the container to create an instance of your class and all dependencies will be automatically resolved (even if your depedencies have dependencies of their own).\r\n\r\nYou can also create something called a _nested container_. In case of the dialog sample you would use this nested container to create all the view models that are only relevant during the dialog's lifetime. When the dialog closes, you can dispose the nested container and automatically all of the objects created by that container will be disposed as well. Still sounds complex? Read on!\r\n\r\n### How do I include it?\r\nIt can be loaded as an CommonJS/Node.JS or AMD module. If you don't have either, it will be available as `window.intravenous`. It has no dependencies on other libraries.\r\n\r\n### How do I use it?\r\n1. Create a container like this:\r\n```javascript\r\nvar container = intravenous.create();\r\n```\r\n\r\n1. Next, register some services (can be a constructor function or just an object):\r\n```javascript\r\ncontainer.register(\"logger\", loggerClass);\r\ncontainer.register(\"someGlobalData\", { data: \"hello\" });\r\n```\r\n\r\n1. Then, define a class and its dependencies\r\n```javascript\r\nvar myClass = function(logger, someGlobalData) {\r\n  /* use logger here */\r\n};\r\nmyClass.$inject = [\"logger\", \"someGlobalData\";\r\ncontainer.register(\"myClass\", myClass);\r\n```\r\n\r\n1. Finally, get an instance to this class through the container:\r\n```javascript\r\nvar myInstance = container.get(\"myClass\");\r\n```\r\n\r\nYou will now have an instance of `myClass` with all its dependencies resolved.\r\n\r\n### What if a service doesn't exist?\r\nIt will throw an exception. Alternatively, you can specify optional (or nullable) dependencies by using the `?` suffix, like so:\r\n\r\n```javascript\r\nmyClass.$inject = [\"logger\", \"optionalDependency?\"];\r\n```\r\n\r\nIn this case `optionalDependency` will be injected as `null` if it doesn't exist.\r\n\r\n### How can I control object disposal?\r\nPass in an `onDispose` handler when you create the container:\r\n```javascript\r\nvar container = intravenous.create({\r\n  onDispose: function(obj, serviceName) {\r\n    obj.yourDisposeFunction();\r\n  }\r\n});\r\n```\r\n\r\nNow, whenever you are done with your container, call `dispose` on the container and it will call your `onDispose` callback for every object that needs to be disposed.\r\n\r\n### What if I want to dispose only parts of the container, instead of everything?\r\nUse a nested container and dispose that instead:\r\n```javascript\r\nvar container = intravenous.create(/* onDispose handler here */);\r\nvar nested = container.create();\r\nvar myInstance = nested.get(\"myClass\");\r\nnested.dispose();\r\n```\r\n\r\nYou can also register additional services on the nested container. They will override services registered on the parent container.\r\n\r\nCreating a nested container is very lightweight so it's highly recommended to use them.\r\n\r\nPlease note that `container.create()` is not the same as `intravenous.create()`. The first creates a nested container, the second creates a completely new intravenous container. Typically in your application you will only need a single intravenous container.\r\n\r\n### But how can I get access to the main intravenous container?\r\nTake a dependency on the service called `container`, like so:\r\n\r\n```javascript\r\nvar myClass = function(container) {\r\n  var nested = container.create();\r\n}\r\nmyClass.$inject = [\"container\", /* ... other dependencies */];\r\n```\r\n\r\n### How can I control the lifecycle of a service?\r\nWhen registering a service using `register` it will default to the `perRequest` lifecycle. There are a number of different lifecycles you can use, though. They are listed below.\r\n\r\nLet's say you have a service called `foo` and you are resolving an object `bar` that needs to resolve a large object graph to satisfy all its dependencies. It may mean `foo` is required in a lot of different places.\r\n\r\nThe available lifecycles:\r\n\r\n1. `perRequest`: Regardless of how many times `foo` is required in the object graph, it is only created once. The next call to `container.get` will create a new `foo`, though.\r\n\r\n2. `unique`: Every time `foo` is required in the object graph, a new instance is created.\r\n\r\n3. `singleton`: As long as the container is not disposed, `foo` will only be created once. It will also be reused across multiple calls to `container.get`.\r\n\r\nThe lifecycle is specified as the third argument to `register`:\r\n```javascript\r\ncontainer.register(\"logger\", loggerClass, \"singleton\");\r\n```\r\n\r\n### How can I specify additional arguments?\r\nWhen you want to pass additional to your class, simply add them to the `container.get` call:\r\n\r\n```javascript\r\nvar myClass = function(logger, extra) {\r\n  alert(extra);\r\n};\r\nmyClass.$inject = [\"logger\"];\r\ncontainer.register(\"myClass\", myClass);\r\nvar myInstance = container.get(\"myClass\", \"hello!\");\r\n```\r\n\r\nThis example will alert `hello!`.\r\n\r\n### Can I also create instances of services I haven't yet registered?\r\nNo, not yet.\r\n\r\n### Where did you get inspiration from?\r\nThe `$inject` syntax was inspired by [AngularJS](http://angularjs.org/). The nested container was a good idea pilfered from [StructureMap](http://www.structuremap.net).\r\n\r\n### What's the license?\r\n[MIT](http://www.opensource.org/licenses/mit-license.php).","tagline":"A lightweight inversion of control container for Javascript.","google":"UA-31340321-1","note":"Don't delete this file! It's used internally to help with page regeneration."}